# 浏览器揭秘

## 结构组成

1. 用户界面
2. 浏览器引擎
3. 渲染引擎
4. 网络
5. 用户界面后端
6. JavaScript 解释器
7. 数据存储

## 主流程

渲染引擎一开始会从网络层获取请求文档的内容, 内容的大小一般限制在 8000 个块以内,
然后进行如下所示的基本流程.

渲染引擎将开始解析 HTML 文档, 并将各标记逐个转化为"内容树"上的 Dom 节点. 同时也会解析外部 Css
文件以及样式元素中的样式数据, html 中这些带有视觉指令的样式信息将用于创建另一个树结果: 渲染树.

渲染树包含多个带有视觉属性(如颜色和尺寸)的矩形, 这些矩形的排列顺序就是他们将在屏幕上显示的顺序

渲染树构建完成之后, 进行 "layout" 阶段, 也就是为每个节点分配一个应出现在屏幕上的确切坐标

下一个阶段是 "paint" , 渲染引擎会遍历渲染树, 由用户界面后端将每个节点绘制出来.

需要着重指出, 这是一个渐进的过程, 为达到更好的用户体验, 渲染引擎会力求尽快将内容显示在屏幕上,
它不必等到整个 html 文档解析完毕之后, 就会开始构建渲染树和 layout,
在不断接收和处理来自网络的其余内容的同时, 渲染引擎将部分内容解析并显示出来

![](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png)

## 解析

解析是渲染引擎一个非常重要的环节.

解析文档是指将文档转化为有意义的结构, 也就是可让代码理解和使用的结构,
解析得到的结果通常是代表了文档结构的节点树, 它被称为解析树/语法树

### 语法树

解析以文档所遵循的语法规则为基础, 所有可以解析的格式都必须对应确定的语法, 这称为**与上下文无法的语法**, 人类语言并不属于这样的语言, 因此无法用常规的解析技术进行解析.

### 解析器与词法分析器的结合

解析的过程分为两个子过程: 词法分析和语法分析.

词法分析是将输入内容分割成大量标记的过程, 标记是语言中的词汇, 即构成内容的单元. 在人类语言中,
它相当于语言字典中的单词. 就像英语中的单词

语法分析是应用语言的语法规则的过程. 英语中的句子是否符合语法

解析器将解析工作分为以下两个组件来处理:

1. 词法分析: 负责将输入内容分解成一个个有效的标记,
   词法分析器知道如何将无关的字符(比如空格和换行)分离出来.
2. 解析器: 负责根据语言的语法规则分析文档的结构, 从而构建解析树.

![]()

解析是一个迭代的过程, 通常, 解析器会向词法分析器请求一个新标记, 并将是将其与某条语法规则进行匹配.
如果发现了匹配规则, 解析器会将一个对英语该标记的节点添加到解析树中, 然后继续请求下一个标记.

如果没有规则可以匹配, 解析器就会将标记存储到内部, 并继续请求标记,
直到找到与所有内部存储的标记匹配的规则, 如果找不到任何匹配规则, 解析器就会触发一个异常.
这意味着文档无效, 包含语法错误.

### 解析示例

解析`2+3-1`这个表达式. 我们定义一个简单的数学语言, 用来演示解析的过程.

词汇: 我们用的语言可以包含整数、加号和减号
语法:

1. 构成语言的语法单元: 表达式、项和运算符.
2. 我们用的语言可以包含任意数量的表达式
3. 表达式: 一个项接一个运算符, 然后再接一个项
4. 运算符: 加号/减号
5. 项: 一个整数/表达式

让我们分析一下`2+3-1.`

匹配语法规则的第一个子串是`2`, 根据第 5 条语法规则, 这是一个项.
匹配语法规则的第二个子串是`2+3`, 根据第 3 条规则, 这是一个表达式.
下一个匹配项已经到了输入的结束, `2+3-1`是一个表达式, 因为我们已经知道`2+3`是一个项,
这样就符合"一个项接一个运算符, 然后再接一个项"的规则.

`2++` 不与任何规则匹配, 因此是无效的输入.

### 词汇和语法的正式定义

词汇通常用正则表达式表示.

### 解析器类型

两种基本类型的解析器: 自上而下和自下而上

## html 解析器

html 解析器的任务是将 html 标记解析成解析树.

### 不是与上下文无关的语法

正如我们在解析过程的简介中了解到的, 语法可以用 BNF 等格式进行正式定义.

所有常规解析器都不适用于 html, htm 并不能很容易地用解析器所需的与上下文无关的语法来定义

有一种可以定义 html 的珍贵格式: DTD, 但它不是与上下文无关的语法.

html 和 xml 类似, 为什么 xml 解析器可以使用, html 是一个 xml 变体, 却用不了呢?

区别在于 html 的处理更加"宽松", 它允许省略某些隐式添加的标记, 有时还可以省略开始/结束标记等等,
和 xml 严格的语法不同, html 整体看起来是一种"弹性"的语法.

由此, 这种看上去细微的差别实际上却带来了巨大的影响. 一方面, 这是 html 如此流行的原因: 它能包容错误,
简化开发. 另一方面, 这使得它很难编写正式的语法. 总体来说, html 无法很容易通过常规解析器解析,
也无法通过 xml 解析器解析.

### html DTD

html 的定义采用了 dtd 格式

### dom

解析器的输出"解析树"是由 dom 元素和属性节点构成的树结构, dom 是文档对象模型的缩写,
它是 html 文档的对象表示, 同时也是外部内容与 html 元素之间的接口, 解析树的根节点是 document 对象.

dom 与标记之间是一对一的关系.

```<html>html
<html>
  <body>
    <p>
      Hello World
    </p>
    <div> <img src="example.png"/></div>
  </body>
</html>

```

可翻译成如下的 dom 树:

![](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image015.png)

## html 解析

之前说过, html 无法用常规的自上而下/自下而上的解析器进行解析.

原因在于:

1. 语言的宽容性.
2. 浏览器历来对一些常见的无效 html 用法采取包括态度.
3. 解析过程需要不断的反复. 源内容在解析过程中通常不会改变, 但是在 html 中,
   如果 js 脚本使用了 document.write, 就会添加额外的标记, 因此解析过程实际上会更改输入.

由于不能是用常规的解析技术, 浏览器就创建了自定义的解析器来解析 html. 由两个阶段组成: 标记话和建树.

标记化: 词法分析过程, 将输入内容解析成多个标记. html 标记包括开始标记、结束标记、属性名称和属性值.

标记生成器识别标记, 传递给树构造器, 然后接收下一个字符以识别下一个标记; 如此反复直到输入结束.

![](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image017.png)

### 标记化算法

该算法的输出结果是 html 标记, 该算法使用状态及来表示. 每一个状态接收来自输入信息流的一个或多个字符,
并根据这些字符更新下一个状态. 该决定受到当前标记化状态和树状结构状态的影响.
这意味者即使接收的字符相同, 对于下一个正确的状态也会产生不同的结果, 具体取决于当前的状态.

举个例子, 将下面的 html 标记化:

```html
<html>
  <body>
    Hello world
  </body>
</html>
```

1. 初始状态是"数据状态". 遇到字符`<`时, 状态更新为"标记打开状态"
2. 接收一个 a-z 字符会创建"开始标记", 状态更新为"标记名称状态", 这个状态会一直保存到接收`>`状态.
   在此期间接收的每个字符都会附加到新的标记名称上, 在本例中, 我们创建的标记是 html 标记.
3. 遇到`>`标记时, 会发送当前的标记, 状态更新为"数据状态", `<body>` 标记也会进行同样的处理.
   目前 html 和 body 标记都以处理完成, 现在回到"数据状态", 接收到 Hello world 中的 H 字符时,
   创建并发送字符标记, 直到接收`</body>`中的`<`, 我们将 Hello world 中的每个字符都发送一个字符标记.
4. 遇到`` <``````,回到"标记打开状态", 接收到下一个输入字符 `/`时, 会创建end tag token并更新为"标记名称状态". 我们会再次保持这个状态, 直到接收`>`,
5. 然后将发送新的标记, 并回到"数据状态", `</html>`输入也会进行同样的处理.

![](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image019.png)

### 树构建算法

当解析器被创建时, Document 对象被创建. 在树构建阶段, 以 Document 为根的 Dom 树将被修改,
向其中添加各种元素. 标记生成器发送的每个节点都会由树构建起进行处理.
规范中定义了每个标记所对应的 dom 元素, 这些元素会在接收到相应的标记时创建.
这些元素不仅会添加到 Dom 树中, 还会添加到开放元素的堆栈中.此堆栈用来纠正嵌套不匹配和为关闭的标记.
这个算法也被描述为一个状态机, 这些状态被成为"插入模式".

示例输入的树构建过程:

```html
<html>
  <body>
    Hello world
  </body>
</html>
```

树构建阶段的输入是一个来自标记化阶段的标记序列.

第一个模式是"initial mode", 接收 html 标记后转为"before html"模式, 并在这个模式下重新处理此标记.
这样会创建一个 HTMLHtmlElement 元素, 并将添加到 Document 根对象上.

然后状态改为"before head", 此时我们接收"body"标记, 即使示例中没有"head"标记,
系统也会隐式创建一个 HTMLHeadElement, 并将其添加到树中.

现在我们进入"in head"模式, 然后转入"after head"模式, 系统对 body 标记进行重新处理,
创建并插入 HTMLBodyElement, 同时模式转变为"in body".

现在, 接收由"hello world"字符串生成的一系列字符标记, 接收第一个字符时会创建并插入"Text"节点,
而其他字符也将添加到该节点.

接收 body 结束标记会触发"after body"模式, 现在我们将接收 html 结束标记,然后进行"after after body"模式,
接收到文件结束标记后, 解析过程就此结束.

![](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/image022.gif)

### 解析结束后的操作

在此阶段, 浏览器会将文档标记为交互状态, 并开始解析那么处于"defer"模式的脚本,
也就是那些应在文档解析完成之后才执行的脚本, 然后文档状态设置为"完成", 一个"加载"事件将随之触发.

### 浏览器的容错机制

我们在浏览 html 网页时从来不会看到"语法无效"的错误, 这是因为浏览器会纠正任何无效内容, 然后继续工作.

以下面的 html 代码为例:

```html
<html>
  <mytag>
  </mytag>
  <div>
  <p>
  </div>
    Really lousy HTML
  </p>
</html>
```

在这里, 我已经违反了很多语法规则, 但是浏览器仍然正确的显示这些内容,
因为有大量的解析器代码会纠正 html 的错误.

不同浏览器的错误处理机制相当一致, 这种机制并不是 html 规范, 和术前管理以及前进后退按钮一样,
它也是浏览器在多年发展中的产物.

解析器将标记化的输入解析到文档中，建立起文档树。如果文档的格式良好，解析就很简单了。

> 解析器对标记化输入内容进行解析, 以构建文档树. 如果文档的格式正确, 解析就很简单了.
> 遗憾的是, 我们必须处理许多不符合格式的 html 文档, 所以解析器必须对错误有一定的容忍度.
>
> 我们至少要能够处理以后错误情况:
>
> 1. 明显不能在某些外部标记中添加的元素. 在此情况下, 我们应该关闭所有标记, 直到出现禁止添加的元素,
>    然后再加入该元素.
> 2. 我们不能直接添加的元素.
> 3. 向 inline 元素添加 block 元素.
> 4. 如果这样仍然无效, 关闭所有元素, 直到可以添加元素位置, 或者忽略该标记.

### 容错示例

#### 使用了</br>而不是<br>

有些网站使用了</br> 而不是<br>, 为了与 IE 和 Firefox 兼容, Webkit 将其与<br>做了同样的处理.
代码如下:

```c++
if(t->isCloseTag(brTag) && m_document->inCompatMode()){
  reportError(MalformedBRError);
  t->beginTag=true;
}
```

请注意, 错误处理是在内部进行, 用户不会看到这个过程.

#### 离散表格

离散表格是指位于其他表格内容中, 但是又不在任何一个单元格内的表格.
代码如下:

```html
<table>
  <table>
    <tr>
      <td>inner table</td>
    </tr>
  </table>
  <tr>
    <td>outer table</td>
  </tr>
</table>
```

Webkit 会将层次结构更改为两个同级的表格:

```html
<table>
  <tr>
    <td>inner table</td>
  </tr>
</table>
<table>
  <tr>
    <td>outer table</td>
  </tr>
</table>
```

代码如下:

```c++
if (m_inStrayTableContent && localName == tableTag)
        popBlock(tableTag);
```

Webkit 使用一个堆栈来保存当前的元素内容, 它会从外部表格的堆栈中弹出内部表格.
所以这两个表格就变成同级关系了.

#### 嵌套的表单元素

如果用户在一个表单元素中有放入了另一个表单, 那么第二个表单将会忽略.
代码如下:

```c++
if(!m_currentFormElement){
  m_currentFormElement = new HTMLFormElement(formTag, m_document)
}
```

#### 过于复杂的标记层次结构

只允许最多 20 层同类型标记的嵌套, 如果嵌套超过 20 层, 就会被全部忽略.

```c++
bool HTMLParser::allowNestedRedundantTag(const AtomicString& tagName)
{

unsigned i = 0;
for (HTMLStackElem* curr = m_blockStack;
         i < cMaxRedundantTagDepth && curr && curr->tagName == tagName;
     curr = curr->next, i++) { }
return i != cMaxRedundantTagDepth;
}
```

#### 放错位置的 html/body 结束标签

> 支持格式糟糕的 Html 代码, 不会关闭 body 标签, 有一些网站会在文档还没结束的时候就提前关闭 body 标签,
> 浏览器通过调用 end()来执行关闭操作

```c++
if (t->tagName == htmlTag || t->tagName == bodyTag )
        return;
```

## css 解析
