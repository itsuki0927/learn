# 预防 xss 攻击

上一篇文章讲解了 xss 攻击以及三种类型的攻击方式还有其危害, 那么我们怎么来预防 xss 攻击呢?

## 编码与验证两种基本方法

回想一下, XSS 攻击是一种代码注入: 用户输入被错误地解释为恶意程序代码。为了防止这种类型的代码注入, 需要安全的输入输出处理。对于开发人员来说, 执行安全输入处理有两种根本不同的方式:

- **编码**: 它对用户输入进行转义, 以便浏览器仅将其解释为数据, 而不是代码。
- **验证**: 它过滤用户输入, 以便浏览器将其解释为没有恶意命令的代码。

虽然它们两个是完全不同的方法, 但是它们都有共同点:

- 上下文: 安全输入处理需要根据用户在页面中的位置以不同的方式进行.
- 入站出战: 安全输入处理可以在网站收到输入时(入站)或者网站将输入插入到页面前(出战)执行.
- 前端后端: 需要在前端/后端进行, 这两者在不同情况下都是需要的.

在讲解编码和验证之前, 先介绍一下这三个东西.

### 上下文

上下文, 也可以称为语境, 它就像我们说的一句话, 在不同的语境中表达出来的意思是不同的,
而网页中有许多的上下文可以插入用户输入. 对于不同的上下文, 都必须遵循一定的规则,
以便用户输入不会脱离其上下文并解释为恶意代码.

| 上下文        | 示例代码                             |
| ------------- | ------------------------------------ |
| HTML 元素内容 | `<div>userInput</div>`               |
| HTML 属性值   | `<input value="userInput">`          |
| URL 查询值    | `http://example.com/?name=userInput` |
| Css 值        | `color: userInput`                   |
| JavaScript 值 | `var name = "userInput"`             |

在上述所说的上下文中, 如果首次编码/验证之前插入用户输入, 就会出现 xss 攻击. 然后,
攻击可以通过简单的插入该上下文的结束分隔符并在后面添加恶意代码.

举个 🌰, 如果某个网站在某个时候将用户输入直接插入到 HTML 中, 攻击者就能通过引号开始输入来注入恶意脚本, 如下所示.

应用代码: `<input value="userInput">`
恶意字符串: `"><script>...</script><input value="`
结构代码: `<input value=""><script>...</script><input value"">`

可以通过简单的删除用户输入中的所有引号来防止, 但是仅限于这一种情况,
如果相同的输入被插入到其他上下文, 结束的分割符号不一样, 也会注入恶意代码, 所以基于这个原因,
安全输入总是要根据用户插入的上下文做对应的处理.

### 入站出站

我们好像可以通过在收到用户输入后立即对其进行编码/验证来防止 Xss, 这样子,
任何的恶意字符串在包含在页面中时都应该已经被中和, 并且生成 HTML 的脚本不必关心安全输入处理.

问题是, 就跟上面所说的, 用户输入可以插入到多个上下文中, 没有简单的方法可以确定用户输入何时到达,
最终插入到哪一个上下文中, 并且通常需要将相同的用户输入插入到不同的上下文中. 因此,
依靠入站输入处理来防止 Xss 是一个非常脆弱的解决方案, 很容易出错.

相反, 出站输入处理应该是用来抵御 xss 的主要防线, 因为它可以考虑用户输入将插入的特定上下文.

### 在哪里执行安全输入

在现代 Web 应用程序中, 用户输入由前端、后端共同做处理. 为了防止所有类型的 Xss 攻击,
必须在前后端执行安全输入处理, 而不是某一个端的全部职责.

- 为了防止传统的 Xss(反射型和存储型), 必须在后端执行安全输入处理, 这是后端应该完成的.
- 为了防止服务器不接受恶意代码的字符串(基于 Dom 的), 前端需要执行安全输入处理做拦截. 这是使用 JavaScript 完成的.

上面解释了为什么不同的上下文很重要、入站出站处理的区别以及为什么需要在前后端执行安全输入处理.接下来具体的讲一讲两个主要措施:
编码和验证.

## 编码

编码其实就是转义用户输入的行为, 以便浏览器仅将其解释为数据, 而不是恶意代码.
像我们最常用的转义可能就是将 HTML 转义, 比如说将`<`转义成`&lt`, 将`>`转义成`&gt`.

举个 🌰.

```js
// 转义函数
const escapeHTML = str =>
  str.replace(
    /[&<>'"]/g,
    tag =>
      ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        "'": '&#39;',
        '"': '&quot;',
      }[tag] || tag),
  );

const content = '<script> alert("Xss攻击") </script>';

// 转义过后的字符串
escapeHTML(content);
// '&lt;script&gt; alert(&quot;Xss攻击&quot;) &lt;/script&gt;'
```

看上面例子就知道了, 如果我们插入到页面的字符串被转义的话, 浏览器进行解析时不会解析成 html.

### 在客户端和服务器端代码中编码

在现代 Web 应用程序中, 前端使用的语言都是 JavaScript, 而后端可以使用 Java、Python 或者 Go 来去实现后端服务,
本篇文章主要是讲解前端如何防范 Xss 攻击, 所以不会涵盖任何后端或者框架的编码细节,
更多的是讲解前端如何去防范, JavaScript 提供了不同上下文对数据编码的内置函数等等.

#### 客户端编码

在客户端使用 JavaScript 编码用户输入时, 有几个内置方法和属性可以以上下文感知方式自动编码所有数据:

| 语境          | 方法/属性                                                         |
| ------------- | ----------------------------------------------------------------- |
| html 元素内容 | node.textContent = userInput                                      |
| html 属性值   | element.setAttribute(attribute, userInput)或者 element[attribute] |
| =userInput    |
| url 查询值    | window.encodeURIComponent(userInput)                              |
| css 值        | element.style.property = userInput                                |

上面提到的最后一个上下文(JavaScript 值) 没有包含在这个列表中,
因为 JavaScript 没有提供编码数据的内置方式来包含在 JavaScript 源代码中.

### 编码的限制

即使使用了编码, 也有可能将恶意字符串输入到某些上下文中, 比如说: 用户输入提供 Url 的时候.

```js
document.querySelector('a').href = userInput;
```

尽管 Href 作为 a 元素的属性赋值会自动进行编码,
但这本身并不能阻止攻击者插入以`javascript:`开头的 url,点击这个链接时,
将执行嵌入到 url 中的任何 javascript.

当我们希望用户定义页面代码的一部分时, 编码可能就是一个不适当的解决方案,

## 验证

验证是过滤用户输入的行为, 以便删除其中所有恶意部分, 而不必删除其中的所有代码.
我们用的比较多的方式可能就是允许某些 Html 元素, 禁止某些 html 元素

验证的两个主要特征在实现之间有所不同:

分类策略: 可以使用黑名单/白名单对用户输入进行分类.
验证结果: 可以拒绝或清除被识别为恶意的用户输入.

### 分类策略

#### 黑名单

通过定义黑名单禁止某些元素出现来执行验证看起来是合理的, 如果字符串与黑名单中的元素匹配,
则标记为无效. 例如: 禁止掉上面所说的`javascript:`开头.

但是, 黑名单由两个主要的缺点:

1. 复杂: 准确描述所有可能的恶意字符串是一项非常复杂的任务, 比如说上面禁止的`javascript:`,
   那么我如果使用`JavaScript:`的呢? 你可能会说那我全部转化为小写再去比较就好了,
   那如果是`&#106;avascript:`呢? 又怎么样去去设置黑名单呢?
2. 陈旧: 即时制定了一个完美的黑名单, 如果浏览器添加了允许恶意使用的新功能,
   那么这个看起来完美的黑名单也会失败, 因为它忘记拦截这个新功能了, 我们还得时时刻刻维护这个黑名单, 看起来很耗精力.

#### 白名单

### 过滤

## csp

## 其他

### httponly false
